//   _____________________________________________________________________________________________________________________________________________________
//  |  _________________________________________________________________________________________________________________________________________________  |
//  | | Multimedia Information Systems                                                                                                                  | |
//  | | Homework#2 - Yuv files                                                                                                                          | |
//  | | Alim Furkan CANBULAT - 05140000555                                                                                                              | |
//  | | YUV_PSNR_cal: Programa komut satýrýndan girilen iki tane .yuv uzantýlý resim veya video dosyalrýný Y->U->V sýrasýnda kodlanmýþ þekilde çözerek  | |
//  | | iki dosyanýn her pixelindeki Y, U ve V deðerlerini kendi aralarýnda karþýlaþtýrýp Mean Square Error hesaplayarak PSNR deðerlerini ayrý ayrý he- | |
//  | | saplar.																																		    | |
//  | | komut satýrýnda program þu þekilde çalýþtýrýlýr;																								| |
//  | | .\YUV_PSNR_cal.exe original.yuv distorted.yuv witdh height format(i.e. 4:2:0)																    | |
//  | |_________________________________________________________________________________________________________________________________________________| |
//  |_____________________________________________________________________________________________________________________________________________________|
//
#include "stdafx.h"
#include <iostream>
#include <stdio.h>
#include <string>
#include <ctime>
#include <math.h>
#include <iomanip>

using namespace std;

static int frame_num;
// Yuv_Decoder sýnýfý bir yuv dosyasýnýn sahip olabileceði çoðu özelliði barýndýrmasý için tasarlanmýþtýr.
// Sýnýfýn içindeki nesleler ve özellikleri
// file -> .yuv dosyalarýný binary olarak açmak ve okumak için oluþturulmuþ FILE pointerdýr
// buffer -> .yuv dosyasýndan okunan deðerleri her seferinde dosya açmamak ve dosyadaki verileri tutmak için oluþturulmuþ bir char array dir
// frame_number -> .yuv dosyasý bir video dosyasý ise içinde kaç frame olduðunu tutan bir nesnedir
// total_coeff -> .yuv dosyasýnýn formatýna göre Y, U ve V birimlerinin toplamýný tutan bir nesnedir
// one_frame_size -> videodaki 1 frame'in çözünürlülüðünü tutan nesnedir
// witdh, height -> .yuv dosyasýnýn çözünürlüðünü tutar
// size -> .yuv dosyasýnýn kaç byte olduðunu tutar
// filename -> .yuv dosyasýnýn ismini tutar
// chroma_subsample -> chroma formatýný tutar
// coeff_y, coeff_u, coeff_v -> Y, U ve V birim katsayýlarýný tutar
// func Yuv_Decoder -> Yuv_Decoder sýnýfýný yapýcý(constructor) fonksiyonudur. Dosyanýn adý, çözünürlüðü,chroma formatýný ve frame boyutunu hesaplar 
// func Detect_Size -> .yuv dosyasýný binary olarak okur. Dosyanýn boyutunu bulur ve dosyanýn içindeki bilgileri buffer a atar.
// func Detect_Frame_number -> .yuv dosyasýnýn chroma formatýna göre içerisinde kaç frame olduðunu hesaplar
class Yuv_Decoder
{
public:
	FILE* file;
	uint8_t *buffer;
	double frame_number;
	double total_coeff;
	unsigned int one_frame_size;
	int witdh;
	int height;
	long int size;
	string filename;
	string chroma_subsample;
	double coeff_y, coeff_u, coeff_v;
public:
	Yuv_Decoder(string file_name, int witdh_, int height_, string chroma_subsample_);
	int Detect_Frame_number();
	long int Detect_Size();
};

Yuv_Decoder::Yuv_Decoder(string file_name, int witdh_, int height_, string chroma_subsample_) {
	filename = file_name;
	witdh = witdh_;
	height = height_;
	chroma_subsample = chroma_subsample_;
	Detect_Frame_number();
}

long int Yuv_Decoder::Detect_Size() {
	const char* X = (char*)filename.c_str();
	fopen_s(&file, X, "rb");
	fseek(file, 0, SEEK_END);
	size = ftell(file);
	fseek(file, 0, SEEK_SET);
	buffer = (uint8_t *)malloc(size + 1);
	fread(buffer, size, 1, file);
	fclose(file);
	return size;
}

int Yuv_Decoder::Detect_Frame_number() {
	long int size_file = Detect_Size();
	coeff_y = ((double)chroma_subsample[0] - 48) / 4;
	if (((double)chroma_subsample[2] - 48) == 2 && ((double)chroma_subsample[4] - 48) == 0)
	{
		coeff_u = ((double)chroma_subsample[2] - 48) / 8;
		coeff_v = ((double)chroma_subsample[2] - 48) / 8;
	}
	else if (((double)chroma_subsample[2] - 48) == 2 && ((double)chroma_subsample[4] - 48) == 2) {
		coeff_u = ((double)chroma_subsample[2] - 48) / 4;
		coeff_v = ((double)chroma_subsample[4] - 48) / 4;
	}
	else {
		coeff_u = ((double)chroma_subsample[2] - 48) / 4;
		coeff_v = ((double)chroma_subsample[4] - 48) / 4;
	}
	total_coeff = (double)(coeff_y + coeff_u + coeff_v);
	frame_number = size_file / (witdh*height*((double)total_coeff));
	one_frame_size = (int)(size_file / frame_number);
	return (int)frame_number;
}

int psnr(Yuv_Decoder* x, Yuv_Decoder* y) {
	if (x->one_frame_size != y->one_frame_size) {
		cout << "Dosyalar eþit dosyalar deðil farklý çözünürlükteler!" << endl;
		return -1;
	}
	if (x->frame_number < y->frame_number) {
		frame_num = (int)x->frame_number;
	}
	else
	{
		frame_num = (int)y->frame_number;
	}
	int diff = 0;
	double MSE = 0;
	double PSNR = 0;
	double average_PSNR_Y = 0;
	double average_PSNR_U = 0;
	double average_PSNR_V = 0;
	for (int i = 0; i < frame_num; i++)
	{
		int c = x->one_frame_size*i;
		for (int j = c; j < x->one_frame_size*x->coeff_y / x->total_coeff + c; j++) {
			diff = (int)x->buffer[j] - (int)y->buffer[j];
			MSE += pow(diff, 2);
		}
		MSE = MSE / (double)(x->one_frame_size*x->coeff_y / x->total_coeff);
		PSNR = 10 * log10(255 * 255 / MSE);
		average_PSNR_Y += PSNR;
		cout << "PSNR-Y of " << i + 1 << ".frame = " <<setw(6) <<setprecision(5) << PSNR << " dB" << endl;
		for (int j = x->one_frame_size*x->coeff_y / x->total_coeff + c; j < (x->one_frame_size*x->coeff_y / x->total_coeff) + (x->one_frame_size*x->coeff_u / x->total_coeff) + c; j++) {
			diff = (int)x->buffer[j] - (int)y->buffer[j];
			MSE += pow(diff, 2);
		}
		MSE = MSE / (double)(x->one_frame_size*x->coeff_u / x->total_coeff);
		PSNR = 10 * log10(255 * 255 / MSE);
		average_PSNR_U += PSNR;
		cout << "PSNR-U of " << i + 1 << ".frame = " << setw(6) << setprecision(5) << PSNR << " dB" << endl;
		for (int j = x->one_frame_size*x->coeff_y / x->total_coeff + x->one_frame_size*x->coeff_u / x->total_coeff + c; j < (x->one_frame_size*x->coeff_y / x->total_coeff) + (x->one_frame_size*x->coeff_u / x->total_coeff) + (x->one_frame_size*x->coeff_v / x->total_coeff) + c; j++) {
			diff = (int)x->buffer[j] - (int)y->buffer[j];
			MSE += pow(diff, 2);
		}
		MSE = MSE / (double)(x->one_frame_size*x->coeff_v / x->total_coeff);
		PSNR = 10 * log10(255 * 255 / MSE);
		average_PSNR_V += PSNR;
		cout << "PSNR-V of " << i + 1 << ".frame = " << setw(6) << setprecision(5) << PSNR << " dB" << endl << endl;
	}
	cout << "average PSNR-Y = " << setw(6) << setprecision(5) << average_PSNR_Y /frame_num << " dB" << endl;
	cout << "average PSNR-U = " << setw(6) << setprecision(5) << average_PSNR_U /frame_num<< " dB" << endl;
	cout << "average PSNR-V = " << setw(6) << setprecision(5) << average_PSNR_V /frame_num << " dB" << endl;
	return 1;
}

int main(int argc, char** argv)
{
	if (argc != 6) {
	cout << "Yetersiz veri girdiniz!" << endl;
	return -1;
	}
	time_t current_time;
	time_t previous_time;
	time(&previous_time);
	Yuv_Decoder  ori_yuv_file(argv[1], stoi(argv[3]), stoi(argv[4]), argv[5]);
	Yuv_Decoder  dis_yuv_file(argv[2], stoi(argv[3]), stoi(argv[4]), argv[5]);
	psnr(&ori_yuv_file, &dis_yuv_file);
	time(&current_time);
	cout << endl <<"Calisma zamani "<<current_time - previous_time << "(sec) surdu!"<<endl << endl;
	return 0;
}
